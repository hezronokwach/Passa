
import { User } from '@prisma/client';

/**
 * Interface for blockchain-based authentication services.
 * This defines the contract for interacting with a user's wallet,
 * verifying ownership, and managing connection status.
 */
export interface IBlockchainAuth {
  /**
   * Generates a challenge message for the user to sign.
   * This is a random, unique string to prevent replay attacks.
   * @param publicKey - The public key of the user's wallet.
   * @returns A promise that resolves to the challenge string.
   */
  getChallenge(publicKey: string): Promise<string>;

  /**
   * Verifies that the user has signed the challenge with their private key.
   * @param publicKey - The public key of the user's wallet.
   * @param signature - The signature generated by signing the challenge.
   * @param challenge - The original challenge message.
   * @returns A promise that resolves to an object containing success status and the user if verification is successful.
   */
  verifySignature(publicKey: string, signature: string, challenge: string): Promise<{ success: boolean; user?: User }>;

  /**
   * Initiates a connection to the user's wallet (e.g., Freighter, LOBSTR).
   * @returns A promise that resolves to an object containing the user's public key.
   */
  connectWallet(): Promise<{ publicKey: string }>;

  /**
   * Disconnects from the user's wallet.
   * @returns A promise that resolves when the disconnection is complete.
   */
  disconnectWallet(): Promise<void>;

  /**
   * Checks the current connection status with the wallet.
   * @returns A promise that resolves to the connection status.
   */
  getWalletStatus(): Promise<{ isConnected: boolean; publicKey?: string }>;

  /**
   * Validates the format of a wallet address.
   * @param address - The wallet address to validate.
   * @returns True if the address format is valid, false otherwise.
   */
  validateAddress(address: string): boolean;
}

/**
 * A placeholder implementation that throws errors.
 * This should be replaced with a concrete implementation for a specific blockchain wallet (e.g., Freighter, LOBSTR).
 */
class UnimplementedBlockchainAuth implements IBlockchainAuth {
  getChallenge(publicKey: string): Promise<string> {
    throw new Error('Method not implemented.');
  }
  verifySignature(publicKey: string, signature: string, challenge: string): Promise<{ success: boolean; user?: User; }> {
    throw new Error('Method not implemented.');
  }
  connectWallet(): Promise<{ publicKey: string; }> {
    throw new Error('Method not implemented.');
  }
  disconnectWallet(): Promise<void> {
    throw new Error('Method not implemented.');
  }
  getWalletStatus(): Promise<{ isConnected: boolean; publicKey?: string; }> {
    throw new_Error('Method not implemented.');
  }
  validateAddress(address: string): boolean {
    throw new Error('Method not implemented.');
  }
}

// Export a singleton instance of the unimplemented service.
// The actual implementation will be injected or replaced here.
export const blockchainAuthService: IBlockchainAuth = new UnimplementedBlockchainAuth();
