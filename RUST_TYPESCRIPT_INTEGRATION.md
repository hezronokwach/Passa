# Real Use Case: Artist Accepts Invitation

## The Scenario
John (artist) accepts an invitation to perform at "Afrobeats Festival" for $2000. Here's exactly how Rust and TypeScript communicate:

## Step 1: The Rust Contract (What You Write)
```rust
// artist_agreement.rs
pub fn initialize(organizer: Address, artist: Address, fee: i128) {
    // Store agreement on blockchain
    storage().set("organizer", organizer);
    storage().set("artist", artist);
    storage().set("agreed_fee", fee); // $2000
    storage().set("deposit_paid", false);
}

pub fn pay_deposit() {
    let fee = storage().get("agreed_fee"); // $2000
    let deposit = fee / 2; // $1000
    let artist = storage().get("artist");
    
    // Transfer $1000 USDC to artist
    token::transfer(artist, deposit);
    storage().set("deposit_paid", true);
}
```

## Step 2: Generated TypeScript (Automatic)
```typescript
// Generated by: soroban contract bindings typescript
class ArtistAgreementContract {
  async initialize(organizer: string, artist: string, fee: bigint) {
    // Creates Stellar transaction that calls your Rust function
  }
  
  async payDeposit() {
    // Creates Stellar transaction that calls your Rust function
  }
  
  async getState() {
    // Reads data from your Rust contract
  }
}
```

## Step 3: Your Next.js Code Uses It
```typescript
// invitation-response.ts (your existing file)
export async function acceptInvitation(formData: FormData) {
  // ... your existing logic ...
  
  // NEW: Deploy contract when John accepts
  const contract = new ArtistAgreementContract();
  await contract.initialize(
    "ORGANIZER_ADDRESS", 
    "JOHN_ARTIST_ADDRESS", 
    BigInt(2000 * 1000000) // $2000 in stroops
  );
  
  // Store contract address in your database
  await prisma.artistInvitation.update({
    data: { escrowAccountId: contract.address }
  });
}
```

## What Actually Happens

### When John Clicks "Accept Invitation":
1. **Next.js** calls `acceptInvitation()`
2. **TypeScript** calls `contract.initialize()`
3. **Generated code** creates a Stellar transaction
4. **Stellar network** executes your **Rust contract**
5. **Rust contract** stores: organizer, John's address, $2000 fee
6. **Database** stores the contract address

### Later, When Event Gets Published:
```typescript
// In your auto-publish logic
const contract = new ArtistAgreementContract(contractAddress);
await contract.payDeposit(); // Calls your Rust function
```

1. **TypeScript** calls `contract.payDeposit()`
2. **Rust contract** calculates $2000 ÷ 2 = $1000
3. **Rust contract** transfers $1000 USDC to John's wallet
4. **Rust contract** sets `deposit_paid = true`
5. **John receives $1000** automatically

### In Your React Component:
```typescript
// Shows real-time contract status
const contractState = await contract.getState();
// Returns: { agreed_fee: 2000, deposit_paid: true, ... }
```

## The Communication Flow
```
Next.js → TypeScript Bindings → Stellar Transaction → Rust Contract → Blockchain State
   ↑                                                                        ↓
Database ← Contract Address ← Transaction Hash ← Stellar Response ← Execution Result
```

## Key Points
- **You write**: Rust contract logic
- **Soroban generates**: TypeScript interface
- **You use**: Generated TypeScript like normal functions
- **Rust executes**: On Stellar blockchain automatically
- **State persists**: On blockchain forever

John gets his $1000 deposit without you manually sending any payment!

